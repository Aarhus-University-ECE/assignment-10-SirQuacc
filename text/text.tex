\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{a4paper, total={16cm, 24cm}, top=2cm}
\usepackage{amsmath}
\usepackage{blindtext}
\graphicspath{ {img/} }
\usepackage{listings}
\usepackage{color}
\usepackage{siunitx}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    }
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  numbers=left,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3  
}


\title{Week 10 Programming Assignment}
\author{Steffen Petersen | au722120}
\date{November 14th 2022}

\begin{document}
%\tableofcontents

\maketitle
\vspace{5pt}
\noindent Here is the link for my repository, in which you will find all the edited code files and such.\\
\url{https://github.com/Aarhus-University-ECE/assignment-10-SirQuacc}
\section{}
\includegraphics[width=\linewidth, keepaspectratio=true]{task1}
\vspace{2pt}\\
Here is my code for this function, it can also be found in linked\_list.c
\begin{lstlisting}
    void print_list(node *p) {
        printf("-> %d ", p->value); //Print current value
        if(p->next != NULL) print_list(p->next); //If we're not at the end, recursively send the next node
      }
\end{lstlisting}


\section{}
\includegraphics[width=\linewidth, keepaspectratio=true]{task2}
\vspace{2pt}
Below is the recursive function, it can also be found in linked\_list.c
\begin{lstlisting}
    int sum_squares(node *p) {
        if(p == NULL) return 0; //If we've gotten to the null pointer at the end of the list, or input was empty, return 0
        else return (p->value*p->value + sum_squares(p->next)); //square the input value and recursively add the same from the next nodes.
      }
\end{lstlisting}


\section{}
\includegraphics[width=\linewidth, keepaspectratio=true]{task3} 
The code for this is seen below, and can be found in linked\_list.c
\begin{lstlisting}
  typedef int (*fn_int_to_int)(int);
  node *map(node *p, fn_int_to_int f) { 
    if(p != NULL){ //If not at the end, return a node with the applied function's value and next node being recursive.
      return make_node(f(p->value), map(p->next, f));
    }
    return NULL; //Terminate the list, when the end is reached.
  }
\end{lstlisting}


\section{}
\includegraphics[width=\linewidth, keepaspectratio=true]{task4}
\vspace{5pt}\\
The solutions to this exercise are found in btree.c, and the testing of the program is done via CMake and tests.cpp\\
Also, the solutions are made assuming that ALL nodes on the left of a parent, are smaller than or equal to that parent.\\
Similarly on the right, ALL nodes to the right, also children of children, are larger than the parent.
\end{document}